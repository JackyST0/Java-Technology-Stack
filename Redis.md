### REDIS：

#### 什么是Redis：
* Redis 是一款内存高速缓存数据库。Redis 全称为：Remote Dictionary Server（远程词典服务），使用 C 语言编写，Redis 是一个 key-value 存储系统（键值存储系统），是一个基于内存的键值型 NoSQL 数据库，支持丰富的数据类型，如：String、list、set、zset、hash。
* Redis 是一种支持 key-value 等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

---

#### 为什么要使用Redis：
* ##### 读写性能优异
  Redis 能读的速度是 110000 次 /s, 写的速度是 81000 次 /s。
* ##### 数据类型丰富
  Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
* ##### 原子性
  Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作全并后的原子性执行。
* ##### 丰富的特性
  Redis 支持 publish/subscribe, 通知，key 过期等特性。
* ##### 持久化
  Redis 支持 RDB, AOF 等持久化方式
* ##### 发布订阅
  Redis 支持发布 / 订阅模式
* ##### 分布式
  Redis Cluster
###### Tips：一般是在处理一些热点业务的场景下会使用Redis

---

#### 数据结构介绍：
* Redis 是一个基于 key-value 数据类型的非关系型数据库，key 是一般的 String 类型，不过 value 却可以是多种多样的数据类型：
![Redis](https://raw.githubusercontent.com/JackyST0/Java-Technology-Stack/master/%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)

##### String：
![string](https://raw.githubusercontent.com/JackyST0/Java-Technology-Stack/master/%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/string.png)
```
SETEX 命令可用于解决手机验证码登录的问题
SETNX 命令可用于解决分布式锁问题
```

##### Hash：
![hash](https://raw.githubusercontent.com/JackyST0/Java-Technology-Stack/master/%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/hash.png)

##### List：
![list](https://raw.githubusercontent.com/JackyST0/Java-Technology-Stack/master/%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/list.png)
```
List 数据类型的使用场景一般是可以去实现一个任务队列 
```

##### Set：
![set](https://raw.githubusercontent.com/JackyST0/Java-Technology-Stack/master/%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/set.png)

##### ZSet：
![zset](https://raw.githubusercontent.com/JackyST0/Java-Technology-Stack/master/%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/zset.png)
```
Sorted Set 数据类型的使用场景一般是可以去实现各种热门的排行榜
```

##### Common：
![common](https://raw.githubusercontent.com/JackyST0/Java-Technology-Stack/master/%E7%9B%B8%E5%85%B3%E5%9B%BE%E7%89%87/common.png)

---

#### Redis实战：
1. ##### 使用Redis解决session共享问题代替session的业务流程：
    - ###### session共享存在的问题：
        1. 每台服务器中都有完整的一份 session 数据，服务器压力过大。
        2. session 拷贝数据时，可能会出现延迟
2. ##### 使用Redis缓存降低用户访问并发量带来的服务器读写压力，防止用户直接访问数据库。
    - ###### 业务场景：
        - 低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存 （设置过期时间）
        - 高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存（使用更新策略）
    - ###### 主动更新策略：
        1. Cache Aside Pattern
            - 由缓存的调用者，在更新数据库的同时更新缓存
        2. Read/Write Through Pattern
            - 缓存与数据库整合为一个服务，由服务来维护一致性，
        调用者调用该服务，无需关心缓存一致性问题
        3. Write Behind Caching Pattern
            - 调用者只操作缓存，由其它线程异步的将缓存数据持久化到数据库，保证最终一致      
        
        *（综合各种考虑，一般这里的更新策略选择第一种，可以更好的与业务结合。）*
    - ###### 更新顺序不一致导致的问题：
        1. 先删除缓存，后更新数据库：
            - 数据库更新失败，导致请求再次访问缓存时，发现缓存缺失，再读取数据时，从数据库中读到旧值，此方案会导致缓存中一直存放的都是旧值
        2. 先更新数据库，后删除缓存：
            - 缓存删除失败，导致请求再次访问缓存时，发现缓存命中，并从缓存中读取到旧值，此方案只会存在缓存和数据库短暂数据不一致的情况

        *（综合各种考虑，先更新数据库值，后删除缓存的方案虽然在等待缓存删除完成期间会有短暂的不一致数据存在，但对于商铺详情信息来说，可以接受。）*
3. ##### 缓存穿透：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。
    - ###### 解决方案：
        1. 缓存空对象
            * 优点：实现简单，维护方便
            * 缺点：额外的内存消耗；可能造成短期的不一致
        2. 布隆过滤
            * 优点：内存占用较少，没有多余 key
            * 缺点：实现复杂；存在误判可能
4. ##### 缓存雪崩：缓存雪崩是指在同一时段大量的缓存 key 同时失效或者 Redis 服务宕机，导致大量请求到达数据库，带来巨大压力。
    - ###### 解决方案：
        * 给不同的 Key 的 TTL 添加随机值
        * 利用 Redis 集群提高服务的可用性
        * 给缓存业务添加降级限流策略
        * 给业务添加多级缓存
5. ##### 缓存击穿：缓存击穿问题也叫热点 Key 问题，就是一个被高并发访问并且缓存重建业务较复杂的 key 突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。
    - ###### 解决方案：
        * 互斥锁
        * 逻辑过期
6. ##### Redis实现全局唯一Id：为了增加 ID 的安全性，我们可以不直接使用 Redis 自增的数值，而是拼接一些其它信息。
    - ###### 场景分析：
        1. 如果我们的 id 具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。
        2. 随着我们商城规模越来越大，mysql 的单表的容量不宜超过 500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，他们从逻辑上讲他们是同一张表，所以他们的 id 是不能一样的， 于是乎我们需要保证 id 的唯一性。
7. ##### 乐观锁解决库存超卖问题。
8. ##### 悲观锁解决优惠券一人一单问题。（提示：乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作）
9. ##### 基于 setnx 实现的Redis分布式锁解决集群环境下的并发问题：
    - ###### 需要满足的条件:
        * 可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思
        * 互斥：互斥是分布式锁的最基本的条件，使得程序串行执行
        * 高可用：程序不易崩溃，时时刻刻都保证较高的可用性
        * 高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能
        * 安全性：安全也是程序中必不可少的一环
10. ##### 解决Redis分布式锁误删问题：
    - ###### 需求：修改之前的分布式锁实现，满足：在获取锁时存入线程标示（可以用 UUID 表示）在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致。
        * 如果一致则释放锁
        * 如果不一致则不释放锁
    - ###### 核心逻辑：在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。
11. ##### Lua脚本解决多条命令原子性问题：Redis 提供了 Lua 脚本功能，在一个脚本中编写多条 Redis 命令，确保多条命令执行时的原子性。
12. ##### redission优化分布式锁问题：Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。
    - ###### 基于 setnx 实现的分布式锁存在下面的问题：
        1. 重入问题：重入问题是指获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁。
        2. 不可重试：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。（WatchDog）
        3. 超时释放：我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了 lua 表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患。
        4. 主从一致性： 如果 Redis 提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。（MutiLock）
13. ##### 使用Redis完成异步秒杀思想：
    - ###### 场景分析：很多操作是要去操作数据库的，而且还是一个线程串行执行， 这样就会导致我们的程序执行的很慢，所以我们需要异步程序执行。
    - ###### 优化方案：我们将耗时比较短的逻辑判断放入到 redis 中，比如是否库存足够，比如是否一人一单，这样的操作，只要这种逻辑可以完成，就意味着我们是一定可以下单完 成的，我们只需要进行快速的逻辑判断，根本就不用等下单逻辑走完，我们直接给用户返回成功， 再在后台开一个线程，后台线程慢慢的去执行 queue 里边的消息。
14. ##### 使用Redis消息队列优化异步秒杀思想中使用的阻塞队列（企业一般使用rabbitmq处理此类问题）：
    - ###### 解决方案：使用Redis 5.0 引入的一种新数据类型-Stream，可以实现一个功能非常完善的消息队列。（消费者组）   
15. ##### 利用Redis的sortedSet数据类型实现点赞功能和点赞排行榜。
    - ###### 需求：
        * 同一个用户只能点赞一次，再次点击则取消点赞
        * 如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段 Blog 类的 isLike 属性）
16. ##### 使用Redis的set数据结构实现共同关注功能：在博主个人页面展示出当前用户与博主的共同关注。
    - ###### 解决方案：在 set 集合中，有交集并集补集的 api，我们可以把两人的关注的人分别放入到一个 set 集合中，然后再通过 api 去查看这两个 set 集合中的交集数据。
17. ##### 采用Redis的sortedSet数据类型实现分页查询收件箱。（滚动分页：按时间戳查询）
18. ##### 使用Redis-GEO数据类型实现附近商户查询功能
19. ##### 使用Redis-BitMap数据类型实现用户签到功能和签到统计功能
19. ##### 使用Redis-Hyperloglog数据类型实现UV（独立访客量）的统计功能

---

参考文案：[Redis](http://blog.czk.pub/categories/Redis/)
